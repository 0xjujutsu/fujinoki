use bitflags::bitflags;
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use turbopack_binding::turbo::tasks::{self as turbo_tasks, RcStr, TaskInput};

use super::{embed::Embed, Attachment};
use crate::{
    id::{ChannelId, InteractionId, MessageId, RoleId},
    impl_deserialize_from_bits,
    interactions::InteractionType,
    user::User,
};

#[turbo_tasks::value(shared, eq = "manual")]
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Message {
    /// id of the message
    pub id: MessageId,
    /// id of the channel the message was sent in
    pub channel_id: ChannelId,
    /// the author of this message (not guaranteed to be a valid user)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<User>,
    /// contents of the message
    pub content: String,
    /// when this message was sent
    pub timestamp: RcStr,
    /// when this message was edited (or null if never)
    pub edited_timestamp: Option<RcStr>,
    /// whether this was a TTS message
    pub tts: bool,
    /// whether this message mentions everyone
    pub mention_everyone: bool,
    /// users specifically mentioned in the message
    pub mentions: Vec<User>,
    /// roles specifically mentioned in this message
    pub mention_roles: Vec<RoleId>,
    /// channels specifically mentioned in this message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub mention_channels: Option<Vec<ChannelMention>>,
    /// any attached files
    pub attachments: Vec<Attachment>,
    /// any embedded content
    pub embeds: Vec<Embed>,
    /// reactions to the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reactions: Option<Vec<Reaction>>,
    /// used for validating a message was sent
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<RcStr>,
    /// whether this message is pinned
    pub pinned: bool,
    /// if the message is generated by a webhook, this is the webhook's id
    #[serde(skip_serializing_if = "Option::is_none")]
    pub webhook_id: Option<RcStr>,
    /// type of message
    pub r#type: MessageType,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub activity: Option<MessageActivity>,
    /// sent with Rich Presence-related chat embeds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application: Option<MessageApplication>,
    /// if the message is a response to an Interaction, this is the id of the
    /// interaction's application
    #[serde(skip_serializing_if = "Option::is_none")]
    pub application_id: Option<RcStr>,
    /// data showing the source of a crosspost, channel follow add, pin, or
    /// reply
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message_reference: Option<MessageReference>,
    /// message flags combined as a bitfield
    #[serde(skip_serializing_if = "Option::is_none")]
    pub flags: Option<MessageFlags>,
    /// the message associated with the message_reference
    #[serde(skip_serializing_if = "Option::is_none")]
    pub referenced_message: Option<Box<Message>>,
    /// In preview. Sent if the message is sent as a result of an interaction
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction_metadata: Option<MessageInteractionMetadata>,
    /// Deprecated in favor of interaction_metadata; sent if the message is a
    /// response to an interaction
    #[deprecated = "use interaction_metadata"]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub interaction: Option<JsonValue>,
    /// the thread that was started from this message, includes thread member
    /// object
    #[serde(skip_serializing_if = "Option::is_none")]
    pub thread: Option<Channel>,
    /// sent if the message contains components like buttons, action rows, or
    /// other interactive components
    #[serde(skip_serializing_if = "Option::is_none")]
    pub components: Option<Vec<MessageComponent>>,
    /// sent if the message contains stickers
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sticker_items: Option<Vec<MessageStickerItem>>,
    /// Deprecated the stickers sent with the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stickers: Option<Vec<Sticker>>,
    /// A generally increasing integer (there may be gaps or duplicates) that
    /// represents the approximate position of the message in a thread
    #[serde(skip_serializing_if = "Option::is_none")]
    pub position: Option<i32>,
    /// data of the role subscription purchase or renewal that prompted this
    /// ROLE_SUBSCRIPTION_PURCHASE message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role_subscription_data: Option<RoleSubscriptionData>,
    /// data for users, members, channels, and roles in the message's
    /// auto-populated select menus
    #[serde(skip_serializing_if = "Option::is_none")]
    pub resolved: Option<ResolvedData>,
    /// A poll!
    #[serde(skip_serializing_if = "Option::is_none")]
    pub poll: Option<Poll>,
    /// the call associated with the message
    #[serde(skip_serializing_if = "Option::is_none")]
    pub call: Option<MessageCall>,
}

// TODO implement these (this only exists so deserialization works)
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageComponent {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct ChannelMention {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct Reaction {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageReference {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageApplication {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct Channel {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageStickerItem {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct Sticker {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct RoleSubscriptionData {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct ResolvedData {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct Poll {
    value: bool,
}
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageCall {
    value: bool,
}

bitflags! {
    #[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
    #[derive(Serialize, Default, TaskInput)]
    pub struct MessageType: u8 {
      const DEFAULT = 0;
      const RECIPIENT_ADD = 1;
      const RECIPIENT_REMOVE = 2;
      const CALL = 3;
      const CHANNEL_NAME_CHANGE = 4;
      const CHANNEL_ICON_CHANGE = 5;
      const CHANNEL_PINNED_MESSAGE = 6;
      const USER_JOIN = 7;
      const GUILD_BOOST = 8;
      const GUILD_BOOST_TIER_1 = 9;
      const GUILD_BOOST_TIER_2 = 10;
      const GUILD_BOOST_TIER_3 = 11;
      const CHANNEL_FOLLOW_ADD = 12;
      const GUILD_DISCOVERY_DISQUALIFIED = 14;
      const GUILD_DISCOVERY_REQUALIFIED = 15;
      const GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING = 16;
      const GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING = 17;
      const THREAD_CREATED = 18;
      const REPLY = 19;
      const CHAT_INPUT_COMMAND = 20;
      const THREAD_STARTER_MESSAGE = 21;
      const GUILD_INVITE_REMINDER = 22;
      const CONTEXT_MENU_COMMAND = 23;
      const AUTO_MODERATION_ACTION = 24;
      const ROLE_SUBSCRIPTION_PURCHASE = 25;
      const INTERACTION_PREMIUM_UPSELL = 26;
      const STAGE_START = 27;
      const STAGE_END = 28;
      const STAGE_SPEAKER = 29;
      const STAGE_TOPIC = 31;
      const GUILD_APPLICATION_PREMIUM_SUBSCRIPTION = 32;
      const GUILD_INCIDENT_ALERT_MODE_ENABLED = 36;
      const GUILD_INCIDENT_ALERT_MODE_DISABLED = 37;
      const GUILD_INCIDENT_REPORT_RAID = 38;
      const GUILD_INCIDENT_REPORT_FALSE_ALARM = 39;
    }
}

impl_deserialize_from_bits!(MessageType, u8);

#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageActivity {
    /// type of message activity
    pub r#type: MessageActivityType,
    /// party_id from a Rich Presence event
    #[serde(skip_serializing_if = "Option::is_none")]
    pub party_id: Option<RcStr>,
}

bitflags! {
    #[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
    #[derive(Serialize, Default, TaskInput)]
    pub struct MessageActivityType: u8 {
        const JOIN = 1;
        const SPECTATE = 2;
        const LISTEN = 3;
        const JOIN_REQUEST = 5;
    }
}

impl_deserialize_from_bits!(MessageActivityType, u8);

bitflags! {
  #[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
  #[derive(Serialize, Default, TaskInput)]
  pub struct MessageFlags: u32 {
      /// this message has been published to subscribed channels (via Channel Following)
      const CROSSPOSTED = 1 << 0;
      /// this message originated from a message in another channel (via Channel Following)
      const IS_CROSSPOST = 1 << 1;
      /// do not include any embeds when serializing this message
      const SUPPRESS_EMBEDS = 1 << 2;
      /// the source message for this crosspost has been deleted (via Channel Following)
      const SOURCE_MESSAGE_DELETED = 1 << 3;
      /// this message came from the urgent message system
      const URGENT = 1 << 4;
      /// this message has an associated thread, with the same id as the message
      const HAS_THREAD = 1 << 5;
      /// this message is only visible to the user who invoked the Interaction
      const EPHEMERAL = 1 << 6;
      /// this message is an Interaction Response and the bot is "thinking"
      const LOADING = 1 << 7;
      /// this message failed to mention some roles and add their members to the thread
      const FAILED_TO_MENTION_SOME_ROLES_IN_THREAD = 1 << 8;
      /// this message will not trigger push and desktop notifications
      const SUPPRESS_NOTIFICATIONS = 1 << 12;
      /// this message is a voice message
      const IS_VOICE_MESSAGE = 1 << 13;
  }
}

impl_deserialize_from_bits!(MessageFlags, u32);

#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct MessageInteractionMetadata {
    id: InteractionId,
    r#type: InteractionType,
    user: User,
    // authorizing_integration_owners
    original_response_message_id: Option<MessageId>,
    interacted_message_id: Option<MessageId>,
    triggering_interaction_metadata: Option<InnerMessageInteractionMetadata>,
}

// Duplicated because `triggering_interaction_metadata` only exists on the
// submit action, so the trigger's metadata should not have a
// `triggering_interaction_metadata` property
#[turbo_tasks::value(shared, serialization = "custom", eq = "manual")]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TaskInput, Hash)]
pub struct InnerMessageInteractionMetadata {
    id: InteractionId,
    r#type: InteractionType,
    user: User,
    // authorizing_integration_owners
    #[serde(skip_serializing_if = "Option::is_none")]
    original_response_message_id: Option<MessageId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    interacted_message_id: Option<MessageId>,
}
