// ripped from https://github.com/napi-rs/napi-rs/blob/main/cli/src/utils/typegen.ts

use std::{
    collections::HashMap,
    fs::File,
    io::{BufRead, BufReader},
    path::PathBuf,
};

use anyhow::Result;
use itertools::Itertools;
use serde_json::Value;

const TOP_LEVEL_NAMESPACE: &str = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER: &str = "/* auto-generated by NAPI-RS */\n/* eslint-disable */\n";

#[derive(Debug, PartialEq, Clone)]
enum TypeDefKind {
    Const,
    Enum,
    StringEnum,
    Interface,
    Type,
    Fn,
    Struct,
    Impl,
}

#[derive(Debug, Clone)]
struct TypeDefLine {
    kind: TypeDefKind,
    name: String,
    original_name: Option<String>,
    def: String,
    js_doc: Option<String>,
    js_mod: Option<String>,
}

fn pretty_print(line: &TypeDefLine, const_enum: bool, ident: usize, ambient: bool) -> String {
    let mut s = line.js_doc.clone().unwrap_or_default();
    match line.kind {
        TypeDefKind::Interface => {
            s.push_str(&format!(
                "export interface {} {{\n{}\n}}",
                line.name, line.def
            ));
        }
        TypeDefKind::Type => {
            s.push_str(&format!("export type {} = \n{}", line.name, line.def));
        }
        TypeDefKind::Enum => {
            let enum_name = if const_enum { "const enum" } else { "enum" };
            s.push_str(&format!(
                "{} {} {} {{\n{}\n}}",
                export_declare(ambient),
                enum_name,
                line.name,
                line.def
            ));
        }
        TypeDefKind::StringEnum => {
            if const_enum {
                s.push_str(&format!(
                    "{} const enum {} {{\n{}\n}}",
                    export_declare(ambient),
                    line.name,
                    line.def
                ));
            } else {
                let def = line
                    .def
                    .replace(|c: char| c.is_alphabetic() || c == '=', "")
                    .replace(',', "|");
                s.push_str(&format!("export type {} = {};", line.name, def));
            }
        }
        TypeDefKind::Struct => {
            s.push_str(&format!(
                "{} class {} {{\n{}\n}}",
                export_declare(ambient),
                line.name,
                line.def
            ));
            if let Some(original_name) = &line.original_name {
                if original_name != &line.name {
                    s.push_str(&format!("\nexport type {} = {}", original_name, line.name));
                }
            }
        }
        TypeDefKind::Fn => {
            s.push_str(&format!("{} {}", export_declare(ambient), line.def));
        }
        _ => {
            s.push_str(&line.def);
        }
    }

    correct_string_ident(&s, ident)
}

fn export_declare(ambient: bool) -> &'static str {
    if ambient {
        "export"
    } else {
        "export declare"
    }
}

pub fn process_type_def(
    intermediate_type_file: PathBuf,
    const_enum: bool,
    header: Option<&str>,
) -> Result<(String, Vec<String>)> {
    let mut exports = Vec::new();
    let defs = read_intermediate_type_file(intermediate_type_file)?;
    let grouped_defs = preprocess_type_def(defs);

    let header = header.unwrap_or(DEFAULT_TYPE_DEF_HEADER);
    let mut dts = String::new();

    for (namespace, defs) in grouped_defs.iter().sorted_by_key(|(k, _)| *k) {
        if namespace == TOP_LEVEL_NAMESPACE {
            for def in defs {
                dts.push_str(&pretty_print(def, const_enum, 0, false));
                dts.push_str("\n\n");
                match def.kind {
                    TypeDefKind::Const
                    | TypeDefKind::Enum
                    | TypeDefKind::StringEnum
                    | TypeDefKind::Fn
                    | TypeDefKind::Struct => {
                        exports.push(def.name.clone());
                        if let Some(original_name) = &def.original_name {
                            if original_name != &def.name {
                                exports.push(original_name.clone());
                            }
                        }
                    }
                    _ => {}
                }
            }
        } else {
            exports.push(namespace.clone());
            dts.push_str(&format!("export declare namespace {} {{\n", namespace));
            for def in defs {
                dts.push_str(&pretty_print(def, const_enum, 2, true));
                dts.push('\n');
            }
            dts.push_str("}\n\n");
        }
    }

    if dts.contains("ExternalObject<") {
        dts = format!(
            "{}
export declare class ExternalObject<T> {{
  readonly '': {{
    readonly '': unique symbol
    [K: symbol]: T
  }}
}}
{}",
            header, dts
        );
    } else {
        dts = format!("{}{}", header, dts);
    }

    Ok((dts, exports))
}

fn read_intermediate_type_file(file: PathBuf) -> Result<Vec<TypeDefLine>> {
    let file = File::open(file)?;
    let reader = BufReader::new(file);
    let mut defs = Vec::new();

    for line in reader.lines() {
        let line = line?.trim().to_string();
        if line.is_empty() {
            continue;
        }

        let json_start = line.find('{').unwrap_or(0);
        let json_str = &line[json_start..];
        let value: Value = serde_json::from_str(json_str)?;

        let def = TypeDefLine {
            kind: match value["kind"].as_str().unwrap() {
                "const" => TypeDefKind::Const,
                "enum" => TypeDefKind::Enum,
                "string_enum" => TypeDefKind::StringEnum,
                "interface" => TypeDefKind::Interface,
                "type" => TypeDefKind::Type,
                "fn" => TypeDefKind::Fn,
                "struct" => TypeDefKind::Struct,
                "impl" => TypeDefKind::Impl,
                _ => anyhow::bail!("Unknown TypeDefKind"),
            },
            name: value["name"].as_str().unwrap().to_string(),
            original_name: value["original_name"].as_str().map(|s| s.to_string()),
            def: value["def"].as_str().unwrap().to_string(),
            js_doc: value["js_doc"].as_str().map(|s| s.to_string()),
            js_mod: value["js_mod"].as_str().map(|s| s.to_string()),
        };

        defs.push(def);
    }

    defs.sort_by(|a, b| {
        if a.kind == TypeDefKind::Struct {
            if b.kind == TypeDefKind::Struct {
                a.name.cmp(&b.name)
            } else {
                std::cmp::Ordering::Less
            }
        } else if b.kind == TypeDefKind::Struct {
            std::cmp::Ordering::Greater
        } else {
            a.name.cmp(&b.name)
        }
    });

    Ok(defs)
}

fn preprocess_type_def(defs: Vec<TypeDefLine>) -> HashMap<String, Vec<TypeDefLine>> {
    let mut namespace_grouped = HashMap::new();
    let mut class_defs = HashMap::new();

    for def in defs {
        let namespace = def
            .js_mod
            .clone()
            .unwrap_or_else(|| TOP_LEVEL_NAMESPACE.to_string());
        let group = namespace_grouped.entry(namespace).or_insert_with(Vec::new);

        if def.kind == TypeDefKind::Struct {
            group.push(def.clone());
            class_defs.insert(def.name.clone(), def);
        } else if def.kind == TypeDefKind::Impl {
            if let Some(class_def) = class_defs.get_mut(&def.name) {
                if !class_def.def.is_empty() {
                    class_def.def.push('\n');
                }
                class_def.def.push_str(&def.def);
            }
        } else {
            group.push(def);
        }
    }

    namespace_grouped
}

pub fn correct_string_ident(src: &str, ident: usize) -> String {
    let mut bracket_depth = 0;
    src.lines()
        .map(|line| {
            let line = line.trim();
            if line.is_empty() {
                return String::new();
            }

            let is_in_multiline_comment = line.starts_with('*');
            let is_closing_bracket = line.ends_with('}');
            let is_opening_bracket = line.ends_with('{');
            let is_type_declaration = line.ends_with('=');
            let is_type_variant = line.starts_with('|');

            let mut right_indent = ident;
            if (is_opening_bracket || is_type_declaration) && !is_in_multiline_comment {
                bracket_depth += 1;
                right_indent += (bracket_depth - 1) * 2;
            } else {
                if is_closing_bracket
                    && bracket_depth > 0
                    && !is_in_multiline_comment
                    && !is_type_variant
                {
                    bracket_depth -= 1;
                }
                right_indent += bracket_depth * 2;
            }

            if is_in_multiline_comment {
                right_indent += 1;
            }

            format!("{}{}", " ".repeat(right_indent), line)
        })
        .collect::<Vec<_>>()
        .join("\n")
}

